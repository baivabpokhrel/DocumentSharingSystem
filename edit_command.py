{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "update 0 C\n",
      "update 1 F\n",
      "add 3 A\n",
      "delete 6\n"
     ]
    }
   ],
   "source": [
    "#Reference:\n",
    "#https://people.cs.pitt.edu/~kirk/cs1501/Pruhs/Spring2006/assignments/editdistance/Levenshtein%20Distance.htm\n",
    "#https://web.stanford.edu/class/cs124/lec/med.pdf\n",
    "\n",
    "import numpy as np\n",
    "\n",
    "#*****************\n",
    "#    Functions\n",
    "#*****************\n",
    "#slice a str into a list\n",
    "def to_list(temp_str):\n",
    "    temp_list = []\n",
    "    for i in temp_str:\n",
    "        temp_list.append(i)\n",
    "    return temp_list\n",
    "\n",
    "#return a list containing the minimum edit path\n",
    "def get_path(path_matrix):\n",
    "    def aux(i, j):\n",
    "        if i == 0 and j == 0:\n",
    "            return\n",
    "        else:\n",
    "            temp_path.append([i, j])\n",
    "            \n",
    "        if path_matrix[i][j] == 'U':\n",
    "            aux(i-1, j)\n",
    "        elif path_matrix[i][j] == 'L':\n",
    "            aux(i, j-1)\n",
    "        else:\n",
    "            aux(i-1, j-1)   \n",
    "    temp_path = []\n",
    "    aux(path_matrix.shape[0]-1, path_matrix.shape[1]-1)\n",
    "    temp_path.reverse()\n",
    "    return temp_path\n",
    "        \n",
    "#*************\n",
    "#    Main\n",
    "#*************\n",
    "old_arr = np.array(to_list('ABCDHHEF'))  #to_list('execution'))   \"welcome\", \"the\", \"world\", \"aye\"\n",
    "new_arr = np.array(to_list('CFCDAHHF'))  #to_list('intention'))  \"the\", \"test\", \"str\", \"aaa\"\n",
    "\n",
    "#Initialize a matrix to store the minimum edit distance\n",
    "dist_matrix = np.zeros((old_arr.size+1, new_arr.size+1))\n",
    "path_matrix = np.empty((old_arr.size+1, new_arr.size+1), dtype='str')\n",
    "for i in range(0, new_arr.size+1):\n",
    "    dist_matrix[0][i] = i\n",
    "    path_matrix[0][i] = 'L'\n",
    "for i in range(0, old_arr.size+1):\n",
    "    dist_matrix[i][0] = i\n",
    "    path_matrix[i][0] = 'U'\n",
    "path_matrix[0][0] = 'O'\n",
    "\n",
    "#Find and stroe the min distances in the matrix\n",
    "for col in range (1, new_arr.size+1):\n",
    "    for row in range(1, old_arr.size+1):\n",
    "        if new_arr[col-1] == old_arr[row-1]:\n",
    "            cost = 0\n",
    "        else:\n",
    "            cost = 1\n",
    "        min_cost = min(dist_matrix[row-1][col]+1,\n",
    "                       dist_matrix[row][col-1]+1, \n",
    "                       dist_matrix[row-1][col-1]+cost)\n",
    "        dist_matrix[row][col] = min_cost\n",
    "        \n",
    "        #Find out which operation should be done\n",
    "        if min_cost == dist_matrix[row-1][col]+1:\n",
    "            path_matrix[row][col] = 'U'  #delete\n",
    "        elif min_cost == dist_matrix[row][col-1]+1:\n",
    "            path_matrix[row][col] = 'L'  #add\n",
    "        else:\n",
    "            path_matrix[row][col] = 'D'  #update\n",
    "\n",
    "path = get_path(path_matrix)\n",
    "delete_count = 0\n",
    "\n",
    "for pair in path:\n",
    "    if path_matrix[pair[0]][pair[1]] == 'U':\n",
    "        print(\"delete \" + str(pair[0]-1))\n",
    "        delete_count += 1\n",
    "    elif path_matrix[pair[0]][pair[1]] == 'L':\n",
    "        print(\"add \" + str(pair[0]-1) +\" \"+ str(new_arr[pair[0]-delete_count]))\n",
    "    elif (path_matrix[pair[0]][pair[1]] == 'D' \n",
    "          and dist_matrix[pair[0]][pair[1]] > dist_matrix[pair[0]-1][pair[1]-1]):\n",
    "        print(\"update \" + str(pair[0]-1)+\" \"+ str(new_arr[pair[0]-delete_count-1]))\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.1"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
